#!/usr/bin/env python3
"""
Convert equirectangular images to polar format for POV display.

The polar format is optimized for the POV display:
- Width (720): Angular positions (0° to 359.5° longitude, 0.5° resolution)
- Height (44): Radial positions (row 0 = equator, row 43 = pole)

When wrapped into a disc:
- Row 0 maps to the outer edge of the disc (equator)
- Row 43 maps to the center of the disc (pole)

Usage:
    python convert_to_polar.py assets/2k_earth_daymap.jpg polar_earth --north
    python convert_to_polar.py assets/2k_jupiter.jpg polar_jupiter --south --saturation 1.8 --contrast 1.3
    python convert_to_polar.py assets/2k_moon.jpg polar_moon --north
"""

from pathlib import Path
import argparse

try:
    from PIL import Image, ImageEnhance
    import numpy as np
except ImportError:
    print("Error: PIL and numpy required. Install with:")
    print("  uv pip install pillow numpy")
    exit(1)


def equirect_to_polar(
    input_path: Path,
    hemisphere: str = "north",
    width: int = 720,
    height: int = 44,
    saturation: float = 1.0,
    contrast: float = 1.0,
) -> np.ndarray:
    """
    Convert equirectangular image to polar format.

    Args:
        input_path: Path to equirectangular source image
        hemisphere: "north" or "south" - which pole is at center
        width: Angular resolution (720 = 0.5° per pixel)
        height: Radial resolution (44 rings from equator to pole)
        saturation: Color saturation multiplier (1.0 = unchanged, 1.5 = 50% more vibrant)
        contrast: Contrast multiplier (1.0 = unchanged, 1.3 = 30% more contrast)

    Returns:
        numpy array of shape (height, width, 3) with RGB values
    """
    img = Image.open(input_path).convert("RGB")

    # Apply image enhancements before sampling
    if saturation != 1.0:
        img = ImageEnhance.Color(img).enhance(saturation)
    if contrast != 1.0:
        img = ImageEnhance.Contrast(img).enhance(contrast)
    src_w, src_h = img.size
    src_array = np.array(img)

    polar = np.zeros((height, width, 3), dtype=np.uint8)

    for row in range(height):
        # Row 0 = outer edge (equator), Row max = center (pole)
        if hemisphere == "north":
            # North pole view: lat 0° to 90°
            latitude = 90.0 * row / (height - 1)
        else:
            # South pole view: lat 0° to -90°
            latitude = -90.0 * row / (height - 1)

        # Map latitude to source Y
        # Equirectangular: Y=0 is north pole (lat 90°), Y=max is south pole (lat -90°)
        # Formula: src_y = (90 - latitude) / 180 * src_h
        src_y = int((90.0 - latitude) / 180.0 * src_h)
        src_y = max(0, min(src_h - 1, src_y))

        for col in range(width):
            # Map column to longitude (0° to 360°)
            longitude = col * 360.0 / width
            src_x = int(longitude / 360.0 * src_w) % src_w

            polar[row, col] = src_array[src_y, src_x]

    return polar


def write_c_header(
    polar: np.ndarray,
    output_path: Path,
    array_name: str,
    hemisphere: str,
) -> None:
    """
    Write polar texture as C header file with CRGB array.

    Args:
        polar: numpy array of shape (height, width, 3)
        output_path: Path to output .h file
        array_name: Name for the C array (e.g., "polar_earth")
        hemisphere: "north" or "south" for comment
    """
    height, width, _ = polar.shape

    # Create output directory if needed
    output_path.parent.mkdir(parents=True, exist_ok=True)

    pole_name = "North" if hemisphere == "north" else "South"

    with open(output_path, "w") as f:
        f.write(f"// Auto-generated polar texture ({width}x{height})\n")
        f.write(f"// {pole_name} pole view: row 0 = equator (edge), row max = pole (center)\n")
        f.write("// Generated by tools/convert_to_polar.py\n")
        f.write("#pragma once\n\n")
        f.write("#include <FastLED.h>\n\n")
        f.write(f"static constexpr int {array_name.upper()}_WIDTH = {width};\n")
        f.write(f"static constexpr int {array_name.upper()}_HEIGHT = {height};\n\n")
        f.write(
            f"static const CRGB {array_name}[{array_name.upper()}_HEIGHT][{array_name.upper()}_WIDTH] PROGMEM = {{\n"
        )
        for row in range(height):
            f.write("  {")
            for col in range(width):
                r, g, b = polar[row, col]
                f.write(f"CRGB({r},{g},{b})")
                if col < width - 1:
                    f.write(",")
            f.write("},\n")
        f.write("};\n")

    # Report size
    size_bytes = height * width * 3
    print(f"Generated: {output_path}")
    print(f"  Array: {array_name}")
    print(f"  Hemisphere: {pole_name}")
    print(f"  Dimensions: {width} x {height}")
    print(f"  Size: {size_bytes:,} bytes ({size_bytes / 1024:.1f} KB)")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Convert equirectangular images to polar format for POV display"
    )
    parser.add_argument("input", type=Path, help="Input equirectangular image")
    parser.add_argument("name", help="Output array name (e.g., 'polar_earth')")
    parser.add_argument(
        "--north", action="store_true", help="North pole at center (default)"
    )
    parser.add_argument(
        "--south", action="store_true", help="South pole at center"
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("led_display/src/textures"),
        help="Output directory (default: led_display/src/textures)",
    )
    parser.add_argument(
        "--saturation",
        type=float,
        default=1.0,
        help="Color saturation multiplier (1.0 = unchanged, 1.5 = more vibrant)",
    )
    parser.add_argument(
        "--contrast",
        type=float,
        default=1.0,
        help="Contrast multiplier (1.0 = unchanged, 1.3 = more contrast)",
    )

    args = parser.parse_args()

    if not args.input.exists():
        print(f"Error: Input file not found: {args.input}")
        exit(1)

    hemisphere = "south" if args.south else "north"
    output_path = args.output_dir / f"{args.name}.h"

    print(f"Converting: {args.input}")
    if args.saturation != 1.0 or args.contrast != 1.0:
        print(f"  Saturation: {args.saturation}x, Contrast: {args.contrast}x")
    polar = equirect_to_polar(
        args.input,
        hemisphere=hemisphere,
        saturation=args.saturation,
        contrast=args.contrast,
    )
    write_c_header(polar, output_path, args.name, hemisphere)
    print("Done!")


if __name__ == "__main__":
    main()
