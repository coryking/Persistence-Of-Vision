================================================================================
POV DISPLAY - FLOATING-POINT OPERATIONS REFERENCE
Complete audit of all float/double operations in timing-critical path
================================================================================

CRITICAL TIER (Affects visual output, timing-critical loop):
================================================================================

FILE: src/main.cpp
LINE 264:  double microsecondsPerDegree = static_cast<double>(microsecondsPerRev) / 360.0;
   OPERATION:   double division
   SEVERITY:    CRITICAL (software-emulated double on ESP32-S3)
   FREQUENCY:   Every frame (20-40 times per revolution)
   PRECISION:   Limited (60-bit mantissa for this magnitude)
   FIX:         Change to: float microsecondsPerDegree = ...microsecondsPerRev / 360.0f;

LINE 266:  double angleMiddle = fmod(static_cast<double>(elapsed) / microsecondsPerDegree, 360.0);
   OPERATION:   double division + fmod
   SEVERITY:    CRITICAL (two double operations per frame)
   FREQUENCY:   Every frame (20-40 times per revolution)
   PRECISION:   Accumulated error from previous line
   FIX:         Use integer math: uint16_t angleUnits = (elapsed * 720) / microsecondsPerRev;

LINE 215:  double angleInner = fmod(angleMiddle + INNER_ARM_PHASE, 360.0);
   OPERATION:   fmod with double
   SEVERITY:    HIGH (depends on line 266's precision)
   FREQUENCY:   Every frame
   PRECISION:   Subject to accumulated error
   FIX:         Use integer modulo

LINE 216:  double angleOuter = fmod(angleMiddle + OUTER_ARM_PHASE, 360.0);
   OPERATION:   fmod with double
   SEVERITY:    HIGH (depends on line 266's precision)
   FREQUENCY:   Every frame
   PRECISION:   Subject to accumulated error
   FIX:         Use integer modulo

LINE 247:  static double prevAngleMiddle = -1.0;
   OPERATION:   Double storage
   SEVERITY:    HIGH (accumulates precision loss over 40+ frames)
   FREQUENCY:   Once per frame update
   PRECISION:   Loses one ULP per operation (compound interest of error)
   FIX:         Use float or integer

LINE 271:  double angleDiff = angleMiddle - prevAngleMiddle;
   OPERATION:   Subtraction of two imprecise values
   SEVERITY:    HIGH (magnifies error from both values)
   FREQUENCY:   Only if ENABLE_DETAILED_TIMING
   PRECISION:   Error = error1 + error2
   FIX:         Use float instead

LINE 284:  double angleInner = fmod(angleMiddle + INNER_ARM_PHASE, 360.0);
           (same as line 215 in non-test mode)
   
LINE 285:  double angleOuter = fmod(angleMiddle + OUTER_ARM_PHASE, 360.0);
           (same as line 216 in non-test mode)

LINE 299:  int currentSlot = static_cast<int>(angleMiddle / slotSize);
   OPERATION:   float division to int cast
   SEVERITY:    MEDIUM (can cause frame skipping)
   FREQUENCY:   Every frame
   PRECISION:   Truncates, subject to rounding errors at boundaries
   FIX:         Add safety margin: (angleMiddle + 0.001f) / slotSize

================================================================================

TIMING-CRITICAL TIER (Not in main loop but affects global calculations):
================================================================================

FILE: src/main.cpp
LINE 80:   double simulatedAngle = 0.0;
   OPERATION:   double accumulation (TEST_MODE only)
   SEVERITY:    MEDIUM (only in test mode, but accumulates)
   FREQUENCY:   Every frame in TEST_MODE
   PRECISION:   Error grows over time
   FIX:         Change to float simulatedAngle

LINE 84:   double simulateRotation()
   OPERATION:   Function returning double
   SEVERITY:    MEDIUM (TEST_MODE only)
   FREQUENCY:   Every frame in TEST_MODE
   PRECISION:   Returns accumulated double value
   FIX:         Change return type to float

LINE 95:   double rpm = TEST_RPM;
   OPERATION:   double assignment
   SEVERITY:    MEDIUM (used in subsequent divisions)
   FREQUENCY:   Every frame in TEST_MODE
   PRECISION:   Constant value, but used in double math
   FIX:         Change to: float rpm = TEST_RPM;

LINE 97:   double timeSec = now / 1000000.0;
   OPERATION:   double division
   SEVERITY:    MEDIUM (for RPM variation in TEST_MODE)
   FREQUENCY:   Every frame in TEST_MODE
   PRECISION:   Loses precision for large timestamps
   FIX:         Change to: float timeSec = now / 1000000.0f;

LINE 98:   rpm = 700.0 + 1050.0 * (1.0 + sin(timeSec * 0.5));
   OPERATION:   double arithmetic with sin()
   SEVERITY:    MEDIUM (mathematical expression, TEST_MODE only)
   FREQUENCY:   Every frame in TEST_MODE
   PRECISION:   Accumulates errors from timeSec
   FIX:         Change constants to float literals (1050.0f, etc.)

LINE 103:  double degreesPerMicrosecond = (rpm * 360.0) / 60000000.0;
   OPERATION:   double multiplication and division
   SEVERITY:    MEDIUM (intermediate calculation)
   FREQUENCY:   Every frame in TEST_MODE
   PRECISION:   Two operations, error compounds
   FIX:         Change to: float degrees... = (rpm * 360.0f) / 60000000.0f;

LINE 134:  float rpm = 60000000.0f / static_cast<float>(revTimer.getMicrosecondsPerRevolution());
   OPERATION:   float division
   SEVERITY:    LOW (used only for logging/display, not timing-critical)
   FREQUENCY:   Once per revolution (in hallProcessingTask)
   PRECISION:   Sufficient for RPM display (no sub-degree calculations)
   FIX:         Keep as-is (not critical)

LINE 352:  double rpm = (microsecondsPerRev > 0) ? (60000000.0 / microsecondsPerRev) : 0.0;
   OPERATION:   double division
   SEVERITY:    LOW (logging/instrumentation only)
   FREQUENCY:   Once per frame (only if ENABLE_TIMING_INSTRUMENTATION)
   PRECISION:   Sufficient for CSV output
   FIX:         Keep as-is (not critical)

================================================================================

EFFECT TIER (Shared effects code, used during rendering):
================================================================================

FILE: src/effects/SolidArms.cpp
LINE 37:   uint8_t pattern = static_cast<uint8_t>(normAngle / 18.0f);
   OPERATION:   float division to uint8_t cast
   SEVERITY:    CRITICAL (pattern boundary detector - causes 288° flicker)
   FREQUENCY:   Every frame per arm (3 arms × frame count)
   PRECISION:   Truncates - 287.999 becomes pattern 15 instead of 16!
   ROOT CAUSE:  The 288° boundary problem (see main FLOAT_MATH_AUDIT.md)
   FIX OPTION A: Add epsilon: (normAngle + 0.5f) / 18.0f
   FIX OPTION B: Use integer: pattern = (angleUnits * 2) / 36;

FILE: src/effects/NoiseField.cpp
LINE 19:   uint16_t noiseX = static_cast<uint16_t>(arm.angle * 182.0f);
   OPERATION:   float multiplication
   SEVERITY:    LOW (noise sampling, visual only)
   FREQUENCY:   Every frame per arm
   PRECISION:   Sufficient for noise function input
   FIX:         Not needed

FILE: src/effects/RpmArc.cpp
LINE 12:   float t = static_cast<float>(i) / 29.0f;
   OPERATION:   float division
   SEVERITY:    LOW (palette gradient calculation, per-effect initialization)
   FREQUENCY:   Once per effect start
   PRECISION:   Not time-critical
   FIX:         Not needed

LINE 20:   float normalized = (clamped - RPM_MIN) / (RPM_MAX - RPM_MIN);
   OPERATION:   float division
   SEVERITY:    LOW (effect rendering, not timing-critical)
   FREQUENCY:   Once per frame
   PRECISION:   Sufficient for visual effect
   FIX:         Not needed

FILE: src/effects/PerArmBlobs.cpp
LINE 35:   float radialHalfSize = blob.currentRadialSize / 2.0f;
   OPERATION:   float division
   SEVERITY:    LOW (visual effect parameter)
   FREQUENCY:   Once per blob per frame
   PRECISION:   Sufficient for LED positioning
   FIX:         Not needed

FILE: src/effects/VirtualBlobs.cpp
LINE 34:   float radialHalfSize = blob.currentRadialSize / 2.0f;
   OPERATION:   float division
   SEVERITY:    LOW (visual effect parameter)
   FREQUENCY:   Once per blob per frame
   PRECISION:   Sufficient for LED positioning
   FIX:         Not needed

================================================================================

ANIMATION TIER (Per-frame animation updates):
================================================================================

FILE: src/blob_types.h
LINE 70:   float timeInSeconds = now / 1000000.0f;
   OPERATION:   float division
   SEVERITY:    MEDIUM (divides large uint64 timestamp)
   FREQUENCY:   Once per blob per revolution
   PRECISION:   Loses precision for large timestamps
   NOTES:       Called from onRevolution() callback (not main loop)
   FIX:         Pre-convert timestamp once, reuse: void updateBlobBatch(float timeInSeconds, ...)

LINE 76:   blob.currentStartAngle = blob.wanderCenter + (angleSin / 32768.0f) * blob.wanderRange;
   OPERATION:   float division
   SEVERITY:    MEDIUM (blob position animation)
   FREQUENCY:   Once per blob per revolution
   PRECISION:   Sufficient for visual effect
   NOTES:       Not in timing-critical path (animation only)
   FIX:         Not critical, but could optimize

LINE 77:   blob.currentStartAngle = fmod(blob.currentStartAngle + 360.0f, 360.0f);
   OPERATION:   fmod with float
   SEVERITY:    MEDIUM (angle wrapping)
   FREQUENCY:   Once per blob per revolution
   PRECISION:   Can accumulate error if blob drifts
   NOTES:       Not in timing-critical path
   FIX:         Use integer modulo if optimizing

FILE: src/blob_types.h (continued)
LINE 84:   ((sizeSin / 32768.0f) * 0.5f + 0.5f)
   OPERATION:   float division and arithmetic
   SEVERITY:    MEDIUM (blob size animation)
   FREQUENCY:   Once per blob per revolution
   PRECISION:   Sufficient for visual effect
   FIX:         Not critical

LINE 89:   blob.currentRadialCenter = blob.radialWanderCenter + (radialAngleSin / 32768.0f) * blob.radialWanderRange;
   OPERATION:   float division
   SEVERITY:    MEDIUM (blob radial animation)
   FREQUENCY:   Once per blob per revolution
   PRECISION:   Sufficient for visual effect
   FIX:         Not critical

LINE 97:   ((radialSizeSin / 32768.0f) * 0.5f + 0.5f)
   OPERATION:   float division and arithmetic
   SEVERITY:    MEDIUM (blob radial size animation)
   FREQUENCY:   Once per blob per revolution
   PRECISION:   Sufficient for visual effect
   FIX:         Not critical

================================================================================

HELPER TIER (Utility functions, cached/infrequent):
================================================================================

FILE: include/polar_helpers.h
LINE 23:   angle = fmod(angle, 360.0f);
   OPERATION:   fmod with float
   SEVERITY:    LOW (normalize function, infrequent)
   FREQUENCY:   Once per angle normalization
   PRECISION:   Sufficient for visual operations
   FIX:         Not needed

LINE 59:   float halfWidth = width / 2.0f;
   OPERATION:   float division
   SEVERITY:    LOW (cached within effect render)
   FREQUENCY:   Once per arc calculation
   PRECISION:   Sufficient for visual effect
   FIX:         Not needed

LINE 73:   float halfWidth = width / 2.0f;
   (duplicate of line 59 in different function)

LINE 89:   float halfWidth = width / 2.0f;
   (duplicate of line 59 in different function)

LINE 96:   return (halfWidth - dist) / fadeWidth;
   OPERATION:   float division
   SEVERITY:    LOW (arc intensity calculation)
   FREQUENCY:   Once per pixel in arc
   PRECISION:   Sufficient for visual effect
   FIX:         Not needed

LINE 121:  return static_cast<float>(virtualPos) / 29.0f;
   OPERATION:   float division
   SEVERITY:    LOW (coordinate conversion)
   FREQUENCY:   Infrequent
   PRECISION:   Sufficient for display logic
   FIX:         Not needed

FILE: include/RenderContext.h
LINE 28:   return 60000000.0f / static_cast<float>(microsPerRev);
   OPERATION:   float division
   SEVERITY:    LOW (rpm() method for display)
   FREQUENCY:   Called once per effect render
   PRECISION:   Sufficient for RPM display
   FIX:         Not needed

LINE 43:   float revsPerMicro = 1.0f / static_cast<float>(microsPerRev);
   OPERATION:   float division
   SEVERITY:    LOW (degreesPerRender method)
   FREQUENCY:   Called once per effect render
   PRECISION:   Sufficient for display logic
   FIX:         Not needed

FILE: include/RevolutionTimer.h
LINE 159:  rollingAvg.add(static_cast<double>(intervalForAvg));
   OPERATION:   Addition to rolling average (double type)
   SEVERITY:    MEDIUM (accumulates precision loss)
   FREQUENCY:   Once per revolution
   PRECISION:   Used for smoothing, not critical
   FIX:         Could change to float for speed, but not critical

LINE 162:  smoothedInterval = static_cast<interval_t>(rollingAvg.average());
   OPERATION:   Double to uint64 cast
   SEVERITY:    MEDIUM (used for angle calculations)
   FREQUENCY:   Once per revolution
   PRECISION:   Rounds double to integer (fine for interval)
   FIX:         Not critical

LINE 187:  float microsecondsPerDegree = static_cast<float>(smoothedInterval) / 360.0f;
   OPERATION:   float division
   SEVERITY:    MEDIUM (in _calculateOptimalResolution)
   FREQUENCY:   Once per revolution (after warmup)
   PRECISION:   Sufficient for resolution calculation
   FIX:         Could optimize but not critical

LINE 193:  float minResolution = renderTimeWithMargin / microsecondsPerDegree;
   OPERATION:   float division
   SEVERITY:    MEDIUM (adaptive resolution calculation)
   FREQUENCY:   Once per revolution (after warmup)
   PRECISION:   Sufficient for resolution selection
   FIX:         Not critical

FILE: include/RollingAverage.h
LINE 60:   return total / sampleCount;
   OPERATION:   Division (template type dependent)
   SEVERITY:    LOW (averaging operation)
   FREQUENCY:   On-demand for averaging
   PRECISION:   Depends on template type
   NOTES:       Used with double in RevolutionTimer
   FIX:         Not critical

================================================================================

SUMMARY BY SEVERITY
================================================================================

CRITICAL (Fix immediately - affects visual output):
  - src/main.cpp:264-266  (double math in angle calculation)
  - src/effects/SolidArms.cpp:37  (pattern boundary selector)

HIGH (Fix soon - affects precision):
  - src/main.cpp:215-216, 284-285  (fmod operations)
  - src/main.cpp:247, 271  (double storage and comparison)
  - src/main.cpp:299  (slot gating division)

MEDIUM (Fix if optimizing):
  - src/blob_types.h:70-97  (animation calculations)
  - include/RevolutionTimer.h:159-193  (resolution calculations)

LOW (Acceptable as-is):
  - All effect-specific divisions
  - Display and logging operations
  - Polar helper functions

================================================================================

QUICK REFERENCE: Replacement Patterns
================================================================================

PATTERN 1: Replace double with float
  double x = value / 360.0;
  → float x = value / 360.0f;
  (8x faster on ESP32-S3, sufficient precision)

PATTERN 2: Replace division chain with integer math
  double deg = (elapsed / microsecondsPerDegree) % 360.0;
  → uint16_t units = (elapsed * 720) / microsecondsPerRev; units %= 720;
  (10x faster, exact precision)

PATTERN 3: Add epsilon to float comparisons
  if (slot != lastSlot)
  → if (int((angle + 0.001f) / slotSize) != lastSlot)
  (prevents rounding errors at boundaries)

PATTERN 4: Replace modulo wrapping
  angle = fmod(angle + 360.0f, 360.0f);
  → angle_units = (angle_units + 720) % 720;
  (exact wrapping, no precision loss)

================================================================================
EOF
cat /Users/coryking/projects/POV_Project/docs/analysis/FLOAT_OPERATIONS_REFERENCE.txt
